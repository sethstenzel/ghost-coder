"""
Global input listener for capturing keyboard, mouse, and gamepad events.
Supports hotkey registration (1-8 slots) and ZMQ event emission.
"""

from pynput import keyboard, mouse
from inputs import get_gamepad, devices
import threading
import time
import zmq
from typing import Optional, Literal, Dict, Any, List
from dataclasses import dataclass
from enum import Enum


class InputSource(Enum):
    """Types of input sources that can be monitored."""
    KEYBOARD = "keyboard"
    MOUSE = "mouse"
    GAMEPAD = "gamepad"


@dataclass
class HotkeyEvent:
    """Represents a hotkey configuration."""
    slot: int  # 1-8
    source: InputSource
    value: Any  # Key name, button, gamepad code, etc.
    gamepad_name: Optional[str] = None  # Specific gamepad device name (for gamepad source)
    message: Optional[str] = None  # Custom message to emit when hotkey is triggered
    suppress: bool = False  # Whether to suppress/capture the event (prevent OS from seeing it)


class Listener:
    """
    Global input listener supporting keyboard, mouse, and gamepad inputs.

    Features:
    - Global event capture for keyboard, mouse, and gamepad
    - 8 hotkey slots for registration
    - ZMQ event emission
    - Configurable input source for hotkey registration
    """

    def __init__(self, zmq_port: int = 44444):
        """
        Initialize the Listener.

        Args:
            zmq_port: Port for ZMQ PUB/SUB socket (default: 44444)
        """
        # State management
        self._lock = threading.Lock()
        self._hotkeys: Dict[int, Optional[HotkeyEvent]] = {i: None for i in range(1, 9)}
        self._running = False

        # Recording state
        self._recording_slot: Optional[int] = None
        self._recording_source: Optional[InputSource] = None
        self._recording_gamepad_name: Optional[str] = None
        self._recording_message: Optional[str] = None
        self._recording_suppress: bool = False

        # ZMQ setup
        self._zmq_context = zmq.Context()

        # Publisher socket for all events and responses
        self._zmq_pub_socket = self._zmq_context.socket(zmq.PUB)
        self._zmq_pub_socket.bind(f"tcp://*:{zmq_port}")

        # Subscriber socket for commands - connects to same port after small delay
        time.sleep(0.1)  # Allow PUB socket to bind first
        self._zmq_sub_socket = self._zmq_context.socket(zmq.SUB)
        self._zmq_sub_socket.connect(f"tcp://localhost:{zmq_port}")
        self._zmq_sub_socket.setsockopt_string(zmq.SUBSCRIBE, "command")

        # Command handler thread
        self._cmd_thread: Optional[threading.Thread] = None

        # Listeners
        self._keyboard_listener: Optional[keyboard.Listener] = None
        self._mouse_listener: Optional[mouse.Listener] = None
        self._gamepad_thread: Optional[threading.Thread] = None

        # Pressed state tracking (for detecting hotkey triggers)
        self._pressed_keys = set()
        self._pressed_buttons = set()
        self._pressed_gamepad = set()

    def start(self):
        """Start all input listeners."""
        with self._lock:
            if self._running:
                print("[Listener] Already running")
                return

            self._running = True

        # Start keyboard listener with suppression support
        self._keyboard_listener = keyboard.Listener(
            on_press=self._on_keyboard_press,
            on_release=self._on_keyboard_release,
            suppress=False  # We handle suppression by returning False from callbacks
        )
        self._keyboard_listener.start()

        # Start mouse listener with suppression support
        self._mouse_listener = mouse.Listener(
            on_click=self._on_mouse_click,
            on_scroll=self._on_mouse_scroll,
            suppress=False  # We handle suppression by returning False from callbacks
        )
        self._mouse_listener.start()

        # Start gamepad thread
        self._gamepad_thread = threading.Thread(target=self._gamepad_loop, daemon=True)
        self._gamepad_thread.start()

        # Start command handler thread
        self._cmd_thread = threading.Thread(target=self._command_loop, daemon=True)
        self._cmd_thread.start()

        print("[Listener] Started all input listeners and command handler")

    def stop(self):
        """Stop all input listeners."""
        with self._lock:
            if not self._running:
                return

            self._running = False

        # Stop keyboard listener
        if self._keyboard_listener:
            self._keyboard_listener.stop()
            self._keyboard_listener = None

        # Stop mouse listener
        if self._mouse_listener:
            self._mouse_listener.stop()
            self._mouse_listener = None

        # Gamepad thread will stop on its own (daemon)
        # Command thread will stop on its own (daemon)

        # Close ZMQ sockets
        self._zmq_pub_socket.close()
        self._zmq_sub_socket.close()
        self._zmq_context.term()

        print("[Listener] Stopped all input listeners")

    def get_gamepads(self) -> List[Dict[str, Any]]:
        """
        Get a list of available gamepad devices.

        Returns:
            List of dictionaries containing gamepad information
        """
        gamepad_list = []
        for i, dev in enumerate(devices.gamepads):
            name = getattr(dev, 'name', f'Gamepad {i+1}')
            gamepad_list.append({
                'index': i,
                'name': name,
                'device': dev
            })
        return gamepad_list

    def register_hotkey(self, slot: int, source: Literal["keyboard", "mouse", "gamepad"], gamepad_name: Optional[str] = None, message: Optional[str] = None, suppress: bool = False):
        """
        Start recording a hotkey for the specified slot.

        Args:
            slot: Hotkey slot number (1-8)
            source: Input source to monitor ("keyboard", "mouse", or "gamepad")
            gamepad_name: Specific gamepad device name (only for gamepad source)
            message: Custom message to emit when this hotkey is triggered
            suppress: Whether to suppress the event (prevent OS from seeing it)

        Raises:
            ValueError: If slot is not in range 1-8
        """
        if slot < 1 or slot > 8:
            raise ValueError(f"Slot must be between 1 and 8, got {slot}")

        source_enum = InputSource(source)

        # If gamepad source, validate or list available gamepads
        if source_enum == InputSource.GAMEPAD:
            gamepads = self.get_gamepads()
            if not gamepads:
                raise ValueError("No gamepads detected")

            if gamepad_name is None:
                # Use the first gamepad by default
                gamepad_name = gamepads[0]['name']
                print(f"[Listener] No gamepad specified, using: {gamepad_name}")

        with self._lock:
            self._recording_slot = slot
            self._recording_source = source_enum
            self._recording_gamepad_name = gamepad_name
            self._recording_message = message
            self._recording_suppress = suppress

        suppress_str = " (will suppress)" if suppress else ""
        print(f"[Listener] Recording hotkey for slot {slot} from {source}{suppress_str}... Press/click now.")

    def get_hotkey(self, slot: int) -> Optional[HotkeyEvent]:
        """
        Get the hotkey configuration for a specific slot.

        Args:
            slot: Hotkey slot number (1-8)

        Returns:
            HotkeyEvent if configured, None otherwise
        """
        with self._lock:
            return self._hotkeys.get(slot)

    def clear_hotkey(self, slot: int):
        """
        Clear the hotkey configuration for a specific slot.

        Args:
            slot: Hotkey slot number (1-8)
        """
        with self._lock:
            self._hotkeys[slot] = None

        print(f"[Listener] Cleared hotkey slot {slot}")

    def emit(self, topic: str, data: Dict[str, Any]):
        """
        Emit an event via ZMQ.

        Args:
            topic: Message topic/channel
            data: Data dictionary to send
        """
        import json
        message = f"{topic} {json.dumps(data)}"
        self._zmq_pub_socket.send_string(message)

    def _command_loop(self):
        """Handle incoming commands from ZMQ clients."""
        import json

        while True:
            with self._lock:
                if not self._running:
                    break

            try:
                # Set timeout to allow checking running state
                if self._zmq_sub_socket.poll(timeout=100):
                    message = self._zmq_sub_socket.recv_string()

                    # Parse message (format: "topic {json_data}")
                    parts = message.split(" ", 1)
                    if len(parts) != 2:
                        continue

                    topic, data_str = parts
                    if topic != "command":
                        continue

                    try:
                        cmd_data = json.loads(data_str)
                        response = self._handle_command(cmd_data)

                        # Publish response with request_id for matching
                        self.emit("response", response)
                    except json.JSONDecodeError as e:
                        self.emit("response", {"success": False, "error": f"Invalid JSON: {str(e)}"})
                    except Exception as e:
                        self.emit("response", {"success": False, "error": str(e)})
            except Exception as e:
                print(f"[Command Loop] Error: {e}")
                time.sleep(0.1)

    def _handle_command(self, cmd_data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle a command from a client.

        Args:
            cmd_data: Command data dictionary

        Returns:
            Response dictionary
        """
        cmd_type = cmd_data.get("command")
        request_id = cmd_data.get("request_id")  # For matching responses

        response = {"request_id": request_id}

        if cmd_type == "register_hotkey":
            slot = cmd_data.get("slot")
            source = cmd_data.get("source")
            gamepad_name = cmd_data.get("gamepad_name")
            message = cmd_data.get("message")
            suppress = cmd_data.get("suppress", False)

            try:
                self.register_hotkey(slot, source, gamepad_name=gamepad_name, message=message, suppress=suppress)
                response.update({"success": True, "message": f"Started recording hotkey for slot {slot}"})
            except Exception as e:
                response.update({"success": False, "error": str(e)})

        elif cmd_type == "get_hotkey":
            slot = cmd_data.get("slot")
            hotkey = self.get_hotkey(slot)

            if hotkey:
                response.update({
                    "success": True,
                    "hotkey": {
                        "slot": hotkey.slot,
                        "source": hotkey.source.value,
                        "value": hotkey.value,
                        "gamepad_name": hotkey.gamepad_name,
                        "message": hotkey.message,
                        "suppress": hotkey.suppress
                    }
                })
            else:
                response.update({"success": True, "hotkey": None})

        elif cmd_type == "get_all_hotkeys":
            hotkeys = []
            for slot in range(1, 9):
                hotkey = self.get_hotkey(slot)
                if hotkey:
                    hotkeys.append({
                        "slot": hotkey.slot,
                        "source": hotkey.source.value,
                        "value": hotkey.value,
                        "gamepad_name": hotkey.gamepad_name,
                        "message": hotkey.message,
                        "suppress": hotkey.suppress
                    })
                else:
                    hotkeys.append(None)

            response.update({"success": True, "hotkeys": hotkeys})

        elif cmd_type == "clear_hotkey":
            slot = cmd_data.get("slot")
            self.clear_hotkey(slot)
            response.update({"success": True, "message": f"Cleared hotkey slot {slot}"})

        elif cmd_type == "get_gamepads":
            gamepads = self.get_gamepads()
            response.update({
                "success": True,
                "gamepads": [{"index": gp["index"], "name": gp["name"]} for gp in gamepads]
            })

        else:
            response.update({"success": False, "error": f"Unknown command: {cmd_type}"})

        return response

    # ==================== Keyboard Handlers ====================

    def _on_keyboard_press(self, key):
        """Handle keyboard key press events."""
        key_str = self._format_key(key)
        should_suppress = False

        with self._lock:
            # Check if we're recording
            if self._recording_slot and self._recording_source == InputSource.KEYBOARD:
                hotkey = HotkeyEvent(
                    slot=self._recording_slot,
                    source=InputSource.KEYBOARD,
                    value=key_str,
                    message=self._recording_message,
                    suppress=self._recording_suppress
                )
                self._hotkeys[self._recording_slot] = hotkey
                msg_info = f" with message '{self._recording_message}'" if self._recording_message else ""
                suppress_info = " (suppressed)" if self._recording_suppress else ""
                print(f"[Listener] Registered hotkey {self._recording_slot}: Keyboard '{key_str}'{msg_info}{suppress_info}")
                self._recording_slot = None
                self._recording_source = None
                self._recording_message = None
                self._recording_suppress = False
                return

            # Track pressed state
            self._pressed_keys.add(key_str)

            # Check if this triggers any hotkey
            for slot, hotkey in self._hotkeys.items():
                if hotkey and hotkey.source == InputSource.KEYBOARD and hotkey.value == key_str:
                    self._trigger_hotkey(slot, hotkey)
                    if hotkey.suppress:
                        should_suppress = True

        # Suppress the event if any hotkey requested it
        # NOTE: Keyboard suppression may not work reliably on all platforms
        if should_suppress:
            return False

    def _on_keyboard_release(self, key):
        """Handle keyboard key release events."""
        key_str = self._format_key(key)

        with self._lock:
            self._pressed_keys.discard(key_str)

    def _format_key(self, key) -> str:
        """Format a pynput key object to a string."""
        try:
            if hasattr(key, 'char') and key.char:
                return key.char
            return str(key).replace('Key.', '')
        except:
            return str(key)

    # ==================== Mouse Handlers ====================

    def _on_mouse_click(self, _x, _y, button, pressed):
        """Handle mouse click events."""
        if not pressed:
            # Handle release
            button_str = self._format_button(button)
            with self._lock:
                self._pressed_buttons.discard(button_str)
            return

        button_str = self._format_button(button)
        should_suppress = False

        with self._lock:
            # Check if we're recording
            if self._recording_slot and self._recording_source == InputSource.MOUSE:
                hotkey = HotkeyEvent(
                    slot=self._recording_slot,
                    source=InputSource.MOUSE,
                    value=button_str,
                    message=self._recording_message,
                    suppress=self._recording_suppress
                )
                self._hotkeys[self._recording_slot] = hotkey
                msg_info = f" with message '{self._recording_message}'" if self._recording_message else ""
                suppress_info = " (suppressed)" if self._recording_suppress else ""
                print(f"[Listener] Registered hotkey {self._recording_slot}: Mouse '{button_str}'{msg_info}{suppress_info}")
                self._recording_slot = None
                self._recording_source = None
                self._recording_message = None
                self._recording_suppress = False
                return

            # Track pressed state
            self._pressed_buttons.add(button_str)

            # Check if this triggers any hotkey
            for slot, hotkey in self._hotkeys.items():
                if hotkey and hotkey.source == InputSource.MOUSE and hotkey.value == button_str:
                    self._trigger_hotkey(slot, hotkey)
                    if hotkey.suppress:
                        should_suppress = True

        # Suppress the event if any hotkey requested it
        if should_suppress:
            return False

    def _on_mouse_scroll(self, _x, _y, dx, dy):
        """Handle mouse scroll events."""
        scroll_event = f"scroll_{'up' if dy > 0 else 'down'}" if dy != 0 else f"scroll_{'right' if dx > 0 else 'left'}"
        should_suppress = False

        with self._lock:
            # Check if we're recording
            if self._recording_slot and self._recording_source == InputSource.MOUSE:
                hotkey = HotkeyEvent(
                    slot=self._recording_slot,
                    source=InputSource.MOUSE,
                    value=scroll_event,
                    message=self._recording_message,
                    suppress=self._recording_suppress
                )
                self._hotkeys[self._recording_slot] = hotkey
                msg_info = f" with message '{self._recording_message}'" if self._recording_message else ""
                suppress_info = " (suppressed)" if self._recording_suppress else ""
                print(f"[Listener] Registered hotkey {self._recording_slot}: Mouse '{scroll_event}'{msg_info}{suppress_info}")
                self._recording_slot = None
                self._recording_source = None
                self._recording_message = None
                self._recording_suppress = False
                return

            # Check if this triggers any hotkey
            for slot, hotkey in self._hotkeys.items():
                if hotkey and hotkey.source == InputSource.MOUSE and hotkey.value == scroll_event:
                    self._trigger_hotkey(slot, hotkey)
                    if hotkey.suppress:
                        should_suppress = True

        # Suppress the event if any hotkey requested it
        if should_suppress:
            return False

    def _format_button(self, button) -> str:
        """Format a pynput button object to a string."""
        return str(button).replace('Button.', '')

    # ==================== Gamepad Handlers ====================

    def _gamepad_loop(self):
        """Polling loop for gamepad events."""
        while True:
            with self._lock:
                if not self._running:
                    break

            try:
                events = get_gamepad()
                for event in events:
                    # Only process button presses and axis movements
                    if event.ev_type not in ('Key', 'Absolute'):
                        continue

                    # Only process press events (state != 0)
                    if event.state == 0:
                        # Handle release
                        with self._lock:
                            self._pressed_gamepad.discard(event.code)
                        continue

                    gamepad_code = event.code
                    gamepad_device_name = getattr(event.device, 'name', None)

                    with self._lock:
                        # Check if we're recording
                        if self._recording_slot and self._recording_source == InputSource.GAMEPAD:
                            # Check if this is the gamepad we're recording from
                            if self._recording_gamepad_name and gamepad_device_name != self._recording_gamepad_name:
                                continue

                            hotkey = HotkeyEvent(
                                slot=self._recording_slot,
                                source=InputSource.GAMEPAD,
                                value=gamepad_code,
                                gamepad_name=gamepad_device_name,
                                message=self._recording_message,
                                suppress=self._recording_suppress
                            )
                            self._hotkeys[self._recording_slot] = hotkey
                            msg_info = f" with message '{self._recording_message}'" if self._recording_message else ""
                            suppress_info = " (suppressed)" if self._recording_suppress else ""
                            print(f"[Listener] Registered hotkey {self._recording_slot}: Gamepad '{gamepad_device_name}' button '{gamepad_code}'{msg_info}{suppress_info}")
                            self._recording_slot = None
                            self._recording_source = None
                            self._recording_gamepad_name = None
                            self._recording_message = None
                            self._recording_suppress = False
                            continue

                        # Track pressed state
                        if gamepad_code not in self._pressed_gamepad:
                            self._pressed_gamepad.add(gamepad_code)

                            # Check if this triggers any hotkey
                            for slot, hotkey in self._hotkeys.items():
                                if (hotkey and
                                    hotkey.source == InputSource.GAMEPAD and
                                    hotkey.value == gamepad_code and
                                    (hotkey.gamepad_name is None or hotkey.gamepad_name == gamepad_device_name)):
                                    self._trigger_hotkey(slot, hotkey)

            except Exception as e:
                # No gamepad connected or other error
                time.sleep(0.5)
                continue

            time.sleep(0.01)  # Small delay to prevent CPU spinning

    # ==================== Hotkey Triggering ====================

    def _trigger_hotkey(self, slot: int, hotkey: HotkeyEvent):
        """
        Trigger a hotkey event.

        Args:
            slot: Hotkey slot number
            hotkey: The hotkey event that was triggered
        """
        print(f"[Listener] Hotkey {slot} pressed: {hotkey.source.value} '{hotkey.value}'")

        # Emit ZMQ event
        event_data = {
            "slot": slot,
            "source": hotkey.source.value,
            "value": hotkey.value
        }
        if hotkey.gamepad_name:
            event_data["gamepad_name"] = hotkey.gamepad_name
        if hotkey.message:
            event_data["message"] = hotkey.message

        self.emit("hotkey", event_data)


# Example usage
if __name__ == "__main__":
    listener = Listener(zmq_port=44444)
    listener.start()

    print("\nListener is running!")
    print("Try registering some hotkeys!")
    print("\nCommands:")
    print("  register <slot> <source> `message` - Register a hotkey (e.g., 'register 1 keyboard `my message`')")
    print("  gamepads - List available gamepads")
    print("  list - List all registered hotkeys")
    print("  clear <slot> - Clear a hotkey slot")
    print("  quit - Exit")

    try:
        while True:
            cmd = input("\n> ").strip().lower()

            if cmd == "quit":
                break
            elif cmd == "gamepads":
                gamepads = listener.get_gamepads()
                if gamepads:
                    print("\nAvailable gamepads:")
                    for gp in gamepads:
                        print(f"  {gp['index']}: {gp['name']}")
                else:
                    print("\nNo gamepads detected")
            elif cmd == "list":
                print("\nRegistered hotkeys:")
                for slot in range(1, 9):
                    hotkey = listener.get_hotkey(slot)
                    if hotkey:
                        msg_str = f" - Message: '{hotkey.message}'" if hotkey.message else ""
                        suppress_str = " [SUPPRESSED]" if hotkey.suppress else ""
                        if hotkey.gamepad_name:
                            print(f"  {slot}: {hotkey.source.value} '{hotkey.value}' (gamepad: {hotkey.gamepad_name}){msg_str}{suppress_str}")
                        else:
                            print(f"  {slot}: {hotkey.source.value} '{hotkey.value}'{msg_str}{suppress_str}")
                    else:
                        print(f"  {slot}: (empty)")
            elif cmd.startswith("register "):
                # Parse message enclosed in backticks
                import re
                match = re.match(r'register\s+(\d+)\s+(\w+)(?:\s+`([^`]*)`)?', cmd, re.IGNORECASE)

                if match:
                    try:
                        slot = int(match.group(1))
                        source = match.group(2).lower()
                        message = match.group(3) if match.group(3) else None

                        # If registering a gamepad hotkey, show gamepad selection
                        if source == "gamepad":
                            gamepads = listener.get_gamepads()
                            if not gamepads:
                                print("Error: No gamepads detected")
                                continue

                            print("\nAvailable gamepads:")
                            for gp in gamepads:
                                print(f"  {gp['index']}: {gp['name']}")

                            gamepad_choice = input("Select gamepad (index or press Enter for first): ").strip()
                            selected_gamepad = None

                            if gamepad_choice == "":
                                selected_gamepad = gamepads[0]['name']
                            else:
                                try:
                                    idx = int(gamepad_choice)
                                    if 0 <= idx < len(gamepads):
                                        selected_gamepad = gamepads[idx]['name']
                                    else:
                                        print(f"Error: Invalid gamepad index")
                                        continue
                                except ValueError:
                                    print(f"Error: Invalid input")
                                    continue

                            listener.register_hotkey(slot, source, gamepad_name=selected_gamepad, message=message)
                        else:
                            listener.register_hotkey(slot, source, message=message)

                    except ValueError as e:
                        print(f"Error: {e}")
                else:
                    print("Usage: register <slot> <source> `message`")
            elif cmd.startswith("clear "):
                parts = cmd.split()
                if len(parts) == 2:
                    try:
                        slot = int(parts[1])
                        listener.clear_hotkey(slot)
                    except ValueError as e:
                        print(f"Error: {e}")
                else:
                    print("Usage: clear <slot>")
            else:
                print("Unknown command")

    except KeyboardInterrupt:
        print("\nInterrupted")

    finally:
        listener.stop()
        print("Listener stopped")
